# Laravel Deployment - Brain Dump!

Date: Thu Oct 19 14:08:18 2017 +0300

The following documents a handful of gotchas I picked up deploying Laravel applications on shared hosting servers.

<br>

## Contents

- [Server Requirements](#server-requirements)
- [About Dotenv](#about-dotenv)
- [Static Assets: css, sass, js and img](#static-assets)
- [Node Modules](#node-modules)
- [Composer Packages](#composer-packages)
- [Database Dumps](#database-dumps)
- [Optimization](#optimization)
- [Shared Hosting](#shared-hosting)
- [Last words](#last-words)

<br>

<div id="#server-requirements"></div>

## Server Requirements

The Laravel framework has a few system requirements. Make sure you server meets the following:

- PHP >= 7.0.0
- OpenSSL PHP Extension
- PDO PHP Extension
- Mbstring PHP Extension
- Tokenizer PHP Extension
- XML PHP Extension

I wrote a script to test these server requirements

See [gistfile](https://gist.github.com/joshuamabina/9575e46ba9e70a416ba80d6870fa846f).

I hear you! Too lazy to `phpinfo()`, ahh?

<br>

<div id="#about-dotenv"></div>

## About Dotenv

### What is it?

Dotenv files are your friend. I like to think of them as **.ini files** on steriods. PHP uses ini files for configurations. Basically, simple text files composed of sections with key-value properties that define how a system is setup.

Here's a section copied from php.ini file:

```ini
#/path/to/php/lib/php.ini

;;;;;;;;;;;;;;;;
; File Uploads ;
;;;;;;;;;;;;;;;;

; Whether to allow HTTP file uploads.
; http://php.net/file-uploads
file_uploads = On
```
### Why should you we use them?

Including your secret credentials in your source files is not such a smart thing to do. They should be stored some place else. In your head, for starters.

[PHPDotenv](https://github.com/vlucas/phpdotenv) was designed to lessen the burden of configuring a project on different environments i.e. locally, staging, testing, production e.t.c.

A simple example of a `.env` file:

```bash
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64_application_key

DB_DATABASE=forge
DB_USERNAME=forge
DB_PASSWORD=secret
```
Use `.env` or `.env.production` or `.env.testing` (notice the convention) to store configuration values specific to the respective dot-environment.

### Why the convention?

Lets look at some code:

```bash
#modify the .env APP_KEY value
$ php artisan key:generate

#modify the .env.testing APP_KEY value
$ php artisan key:generate --env=testing
```

Convetions are good. They just work!

### Gotchas

#### Don't source your secret credentials

DO NOT EVER change `config/something.php` to store credentials.

```php
#good
'mysql' => [
	'driver' => 'mysql',
	'host' => env('DB_HOST', '127.0.0.1'),
	'port' => env('DB_PORT', '3306'),
	'database' => env('DB_DATABASE', 'fake_db'),
	'username' => env('DB_USERNAME', 'fake_user'),
	'password' => env('DB_PASSWORD', 'fake_secret'),
	//...
],
```
I would gladly give anyone a rope for which they hang themselves with, before letting them dump secret credentials in a `config/database.php` (and the like) for whatsoever sane reason they think they have.

#### Don't version your .env files

The `.env[.production|.testing|.environment]` file must not be versioned.

It is a common practice to stub all required environment variables in a `.env.example` file and version that file. So for testing, we would have (recall the convention) `.env.testing.example`.

<br>

<div id="#static-assets"></div>

## Static Assets: css, sass, js and img.

> **tl;dr** DO NOT USE `public/assets` to store your source static assets.

Your `project/resources/assets` directory is your static assets' spouse. Do not set them apart. In other words, store all your source static assets in `project/resources/assets` instead of `public/assets`. The `public/assets` directory is (should be) generated by your build tool (i.e. laravel-mix).

Here is a link to a nice article [Introducing Laravel Mix](https://mattstauffer.com/blog/introducing-laravel-mix-new-in-laravel-5-4/).

### In a nutshell:

Use package-manager to install dependencies:

```bash
$ yarn install
```
Setup Laravel Mix:

```js
//file: project/webpack.mix.js

const { mix } = require('laravel-mix');

mix.sass('resources/assets/sass/app.scss', 'public/css')
.js('resources/assets/js/app.js', 'public/js')
.copy('resources/assets/img', 'public/img');
```
Bootstrap your vendor assets:

```js
//file: project/resources/assets/js/bootstrap.js

window.$ = window.jQuery = require('jquery');
require('bootstrap-sass');
```

Bundle your source and vendor assets together:

```js
//file: project/resources/assets/js/app.js
require('./bootstrap');

/** custom libraries **/
require('./libs/ajaj');
require('./libs/custom-cool-tool');
```
Compile all static assets for specified environment

```bash
#for development
$ yarn dev

#for production
$ yarn production
```

Is it not easy and nice to just think about deploying already optimized stylesheets, javascripts and images?

<br>

<div id="#node-modules"></div>

## Node Modules

> **tl;dr** There is no need to deploy the project with the `node_modules` directory.

### A short walk down memory lane

While it is true that the concept of sanely managing 3rd-party code has been around for quite a long-time (git-submodules, for instance), it is also true that there hasn't been much for JavaScript specific tools until [Node.js](https://nodejs.org/en/).

Node ploughed the JavaScript planet for the better, paving a way for [bower](https://bower.io), [ender](http://www.enderjs.com/), [volo](http://volojs.org/), now [Yarn](https://yarnpkg.com) and everything else errupting from JavaScript's volcanic core, shaking the internet's crust, hard.

Node drastically morphed the JavaScript ecosystem, for the better.

### What is npm?

Their [website](https://npmjs.com), so eloquently states, **&ldquo;npm does not stand for node package manager&rdquo;**.

*Unrelated, **GNU** stands for **GNU's Not UNIX.***

Why npm does not stand for node package manager?

> To be more accurate, npm isn’t **"the package manager for Node.js"**, but **"a package manager for JavaScript"**.

[~ For more, read this long thread.](https://github.com/BloombergMedia/whatiscode/pull/34)

### The story of Yarn

An npm alternative and a bower replacement.

> ...psst! While Bower is maintained, we recommend using Yarn and Webpack for front-end projects...

[~ Bower folks!](https://bower.io)

Built to re-use the rich existing ecosystem of developers and libraries.

Developed by engineers at Facebook, Exponent, Google, and Tilde.

Yarn engineers claim that it is fast, reliable, and a secure dependency manager.

However, not so fast, npm 5 is here **(tires screeching)**.

The re-work on how npm determines how to get the exact same node modules, everytime [puts it slightly ahead](https://github.com/siddharthkp/npm-cache-benchmark).

> Determinism in the context of JavaScript package management is defined as always getting the exact same node modules given a package.json and companion lock file.

[~ Read more on determinism - Yarn vs npm 5](https://yarnpkg.com/blog/2017/05/31/determinism/).

### Node Modules

All dependencies installed by `npm` are stored in the `node_modules` directory. Build tools like webpack refer to this directory for dependencies, compiles them together with source assets and bundles them as instructed.

When bundling completes, it is safe to remove the `node_modules` directory, compress the project and deploy.

```bash
#install dependencies specified in package.json
$ yarn install

#this should work for most cases.
$ yarn production

#it is now safe to...
$ rm -rf node_modules/

#Go bezerk!
tar -zcvf /tmp/source.tar.gz .
```
The size of the `node_modules` directory is almost always frantically huge. With this simple optimization, off you go Santa's naughty list.

<br>

<div id="#composer-packages"></div>

## Composer Packages

> **tl;dr** No need to deploy the entire `vendor` directory.

The vendor directory stores dependencies specified in your `composer.json`.

The dependencies include stuff you would use in production, development, testing e.t.c. We wouldn't want development or testing suff to clout our production environment, or would we?

If your answer is, *NO we wouldn't*, read on.

```bash
#install dependencies specified in composer.json
$ composer install

#estimate file and folder space usage
$ du vendor/
100M   vendor/

#ignore dependencies specified as require-dev
$ composer install --no-dev

#new size estimation
$ du vendor/
30M    vendor/

#deploy a production optimized vendor directory

$ tar -zcvf /tmp/source.tar.gz .
```

Safe and easy on the bandwidth. My boss would love this.

<br>

<div id="#database-dumps"></div>

## Database Dumps

> **tl;dr** Dump the latest state of the database. Inspired by [lally elias](https://github.com/lykmapipo).

I think it is useful to have the latest database snapshot i.e. the schema and real seed-data, altogether, ready for deployment.

So, usually, we would do it like...

```bash
$ php artisan migrate:fresh --seed

$ mysqldump -u root -p laravel > storage/dumps/$(date -u +"%FT%T").sql
```
Now, imagine dragons...

```bash
$ php artisan db:dump mysql

Created Database Dump: yyyy-mm-dd-hh-mm-ss.sql
```

For a more eloquent api, reputable documentation and a well-maintained code, please check out:

- [larkinwhitaker/laravel-db-backup](https://github.com/larkinwhitaker/laravel-db-backup)
- [spatie/laravel-backup](https://docs.spatie.be/laravel-backup/v5/introduction)

<br>

<div id="#optimization"></div>

## Optimization

### Optimizing autoloader

Optimize Composer's autoloader by running the command below:

```bash
composer install -o | --optimize-autoloader
```
The command above regenerates a list of all classes that need to be included in the project.

> **Note:** Prior to Laravel 5.5, we could also achieve this by running: `php artisan dump:autoload`

#### The autoloading story

Not so long ago, referencing code defined in a separate class i.e. separate file, was not a piece of cake. It meant including a handful of include and/or require statements at the top of each class. Some said that this was one of the [biggest annoyances](http://php.net/manual/en/language.oop5.autoload.php).

PHP 5's release brought a savior, `spl_autoload_register()` function which enabled classes and interfaces to be automatically loaded.

PHP developers could now magically make classes talk to each other. One less thing to worry about.

A code example:

```php
<?php

spl_autoload_register(function ($class_name) {

  require_once $documeNT_ROOT.“classes/class.”.$class_name.“.php”;

});

$foo = new Foo;
$foo->hack();
$foo->hack();
$foo->hack();
$foo->shipIt();
$foo->fixInProduction();

//...
```
Wow! It couldn't get any better than this. "I beg to differ", said the Composer.

Composer introduced a much more straightforward API making it a gazillion times easier to autoload source files and vendor files.

```json
//composer.json
{
	"require": {
		"guzzlehttp/guzzle": "4.*",
		"monolog/monolog": "1.*"
	},
	"autoload": {
		"psr-4": {
			"Project\\": "src/Project/"
		}
	}
}
```

I swear, it can not get any better than this. ;)

### Optimizing configuration loading

> **tl;dr** Cut the framework some slack and optimize your configuration files.

Like we've previously covered, all of you application's configuration live in the `config` directory. The framework is responsible for making all those values available to application services whenever needed. Theses services include: connecting database, connecting to Google OAuth e.t.c.

```bash
php artisan config:cache
```

This step simply combines all of the configuration values into a single cached file making it super-duper easy for the framework to retrieve those values, hence a boost on your application's general performance.

### Optimizing route loading

Laravel is designed with a lot of special care to help developers look like they are being productive. It excels at being able to help them build very huge applications with less stress.

When the features of the applications we build become bigger, so do the route files.

We need to optimize the route files by running the command below:

```bash
php artisan route:cache
```

Routes need to be registered before they are used by the application. This command greatly speeds up the route registration process.

Optimization FTW!

### A good thing no closures is. Yes, hrrmmm.

> **tl;dr** French [KISS](https://en.wikipedia.org/wiki/KISS_principle) your route and configuration files.

Caching fails if I throw closures in my route files. So, I do not. Plus, I do not think there's anyting there for me to digest at run-time. I have made french KISS the route and configuration files a principle.

No closures is sometimes a good thing.

<br>

<div id="#shared-hosting"></div>

## Shared Hosting

> **tl;dr** We should be using a VPS.

Sometimes a shared hosting server is all we got.

The usual directory structure in a shared hosting server looks sort of the structure below:

```bash
$ tree -a -L 1
.
├── public_ftp/
├── public_html/ -> /www/
├── tmp/
├── var/
├── www/

//... there be more directories and files

```

The common practice, i.e. when deploying a static website is to dump everything into the `www/` directory. The easiest and straightforward way of deploying laravel apps takes a slightly different approach.

We create a project directory at the same level with `www/`; so something like `project/`.

We dump all of the project's source. Maybe via FTP or git, if SSH access is available.

Gets a little trick from here on.

One needs move all of the contents of `/project/public/` directory into `/www/` so that the project can be reached from the public domain.

An innocent laravel project public directory looks like the tree structure below:

```bash
$ tree -a -L 1
.
├── css/
├── favicon.ico
├── fonts/
├── .htaccess
├── img/
├── index.php
├── js/
├── mix-manifest.json
├── robots.txt
└── storage/ -> /home/joshua/projects/project/storage/app/public

5 directories, 5 files

```

So, dump all that into your server's `www/`.

By now, we should be getting an error when we hit our public domain.

Moving on, open the file `/project/public/index.php`. We will need to modify the path to where the framework registers the autoloader and boots up a Laravel application.

We see the lines

```php
//registers the autoloader
require __DIR__.'/../vendor/autoload.php';

//illuminates the application
$app = require_once __DIR__.'/../bootstrap/app.php';

```
We change them to

```php
//registers the autoloader
require __DIR__.'/../project/vendor/autoload.php';

//illuminates the application
$app = require_once __DIR__.'/../project/bootstrap/app.php';
```
Make sure your dotenv files are in order, and that they reflect the setup on your production environment.

If everything else was properly set, now would be the right time to hit the project from http://ourdomain.com.

### Gotchas

#### Optimizing

It is cumbersome to run optimizations on a shared hosting server, especially if you don't have SSH access.

One thing we could do to get around this, create an optimization handler for when we hit http://ourdomain.com/staging from the address bar. Something like...

```php
<?php
//...

class StagingController extends Controller
{
	public function __construct()
	{
		//checks whether staging environment
		$this->middleware('staging');
	}

	public function index()
	{
		//create storage link
		Artisan::call('storage:link');

		//clear stuff...
		Artisan::call('view:clear');
		Artisan::call('cache:clear');
		Artisan::call('route:clear');
		Artisan::call('config:clear');
		Artisan::call('clear-compiled');
		Artisan::call('medialibrary:clear');

		//cache stuff...
		Artisan::call('route:cache');
		Artisan::call('config:cache');

		return redirect()->index(); //or something else.
	}
}

```

Now, we hit the route http://ourdomain.com/staging and... **big-badda-boom!**

See [gistfile](https://gist.github.com/joshuamabina/544e48c747a8ebba1b0142e5290a7728).

<div id="#last-words"></div>

## Last Words

### Contributing

Found a typo? I accept pull requests.

Think I'm wrong? Got a better idea? Please open an issue, I'd really love to learn more.

### Who should I yell at?

Please share your happy or slimy mimes with me [@joshuamabina](https://twitter.com/joshuamabina).

Please consider motivating me by starring the repository.

Cheers!
