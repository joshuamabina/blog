# Laravel Deployment - Brain Dump!

Date: Thu Oct 19 14:08:18 2017 +0300

The following are some lessons I documented on deploying Laravel applications, mostly based on a shared-hosting context.

**Heads up!** All opinions are mine. Find yours!

<br>

## Contents

- [Server Requirements](#server-requirements)
- [About Dotenv](#about-dotenv)
- [Static Assets: css, sass, js and images](#static-assets)
- [Node Modules](#node-modules)
- [Composer Packages](#composer-packages)
- [Database Dumps](#database-dumps)
- [Optmization](#optimization)
- [Shared Hosting](#shared-hosting)
- [Last words](#last-words)

<br>

<div id="#server-requirements"></div>

## Server Requirements

The Laravel framework has a few system requirements. Make sure you server meets the following:

- PHP >= 7.0.0
- OpenSSL PHP Extension
- PDO PHP Extension
- Mbstring PHP Extension
- Tokenizer PHP Extension
- XML PHP Extension

I wrote a script to test these server requirements.

See [gistfile](https://gist.github.com/joshuamabina/9575e46ba9e70a416ba80d6870fa846f).

<br>

<div id="#about-dotenv"></div>

## About Dotenv

### What is it?

Dotenv files are your friend. I like to think of them as **.ini files** on steriods. PHP uses ini files for configurations. Basically, simple text files composed of sections with key-value properties that define how a system is setup.

Here's a section copied from my php.ini file:

```ini
#/path/to/php/lib/php.ini

;;;;;;;;;;;;;;;;
; File Uploads ;
;;;;;;;;;;;;;;;;

; Whether to allow HTTP file uploads.
; http://php.net/file-uploads
file_uploads = On
```
### Why should you I use them?

Including your secret credentials in your source files, is not such a smart thing to do. They should be stored some place else. In your head, for instance.

*PHPDotenv (requires a link to resource)* was designed to allow the use of different configuration values in different environments.

A simple example of a `.env` file:

```bash
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64_application_key

DB_DATABASE=forge
DB_USERNAME=forge
DB_PASSWORD=secret
```

Use `.env` or `.env.production` or `.env.testing` (notice the convention) to store configuration values specific to the respective dot-environment.

### Why the convention?

Lets look at some code:

```bash
#modify the .env APP_KEY value
$ php artisan key:generate

#modify the .env.testing APP_KEY value
$ php artisan key:generate --env=testing
```

Convetions are good. They just work!

### Caveat: Don't source your credentials

DO NOT EVER change `config/something.php` to store credentials.

```php
#good
'mysql' => [
    'driver' => 'mysql',
    'host' => env('DB_HOST', '127.0.0.1'),
    'port' => env('DB_PORT', '3306'),
    'database' => env('DB_DATABASE', 'fake_db'),
    'username' => env('DB_USERNAME', 'fake_user'),
    'password' => env('DB_PASSWORD', 'fake_secret'),
    //...
],
```

I would gladly give anyone a rope for which they hang themselves before letting them dump credentials in a `config/database.php` for whatsoever sane reason they think they have.

### Caveat: Don't version your .env files

The `.env[.production|.testing|.environment]` file is (and must) not be versioned.

It is a common practice to stub all required environment variables in a `.env.example` file and version that file. So for testing, I would have (recall the convention) `.env.testing.example`.

<br>

<div id="#static-assets"></div>

## Static Assets: css, sass, js and images.

> **tl;dr** DO NOT USE `public/assets` to store your source static assets.

Your `project/resources/assets` directory is your static assets' spouse. Do not set them apart. In other words, store all your source static assets in `project/resources/assets` instead of `public/assets`. The `public/assets` directory is (should be) generated by your build tool (i.e. laravel-mix).

Here is a link to a nice article [Introducing Laravel Mix](https://mattstauffer.com/blog/introducing-laravel-mix-new-in-laravel-5-4/).

In a nutshell:

- Use package-manager to install dependencies:

    ```bash
    $ yarn install
    ```
- Setup Laravel Mix:

    ```js
    //file: project/webpack.mix.js

    const { mix } = require('laravel-mix');

    mix.sass('resources/assets/sass/app.scss', 'public/css')
       .js('resources/assets/js/app.js', 'public/js')
       .copy('resources/assets/img', 'public/img');
    ```
- Bootstrap your vendor assets:

    ```js
    //file: project/resources/assets/js/bootstrap.js

    window.$ = window.jQuery = require('jquery');
    require('bootstrap-sass');
    ```

- Bundle your source and vendor assets together:

    ```js
    //file: project/resources/assets/js/app.js
    require('./bootstrap');

    /** custom libraries **/
    require('./libs/ajax');
    require('./libs/custom-cool-tool');

- Compile all static assets for specified environment

    ```bash
    #for development
    $ yarn dev

    #for production
    $ yarn production
    ```

Is it not easy and nice to just think about deploying already optimized stylesheets, javascripts and images?

<br>

<div id="#node-modules"></div>

## Node Modules

> **tl;dr** There is no need to deploy the project with the `node_modules` directory.

### A short walk down memory lane

Node drastically changed how JavaScript development took form.

While it is true that the concept of sanely managing 3rd-party code has been around for quite a long-time (git-submodules, for instance), this was not much of the case in the JavaScript ecosystem.

Node and affiliates ploughed the JavaScript planet for the better. Then [bower](https://bower.io), [ender](http://www.enderjs.com/), [volo](http://volojs.org/) and everything else, quickly errupted from JavaScript's volcanic core, shaking the Internet's crust, hard.

### What is npm?

Their [website](https://npmjs.com), so eloquently states, **&ldquo;npm does not stand for node package manager&rdquo;**.

*Unrelated, **GNU** stands for **GNU's Not UNIX.***

Why npm does not stand for node package manager?

> To be more accurate, npm isn’t “the package manager for Node.js”, but “a package manager for JavaScript”.

\- [For more, read this long thread.](https://github.com/BloombergMedia/whatiscode/pull/34)

### The Story of Yarn - Yet another package manager.

An npm alternative and a bower replacement.

> ...psst! While Bower is maintained, we recommend using Yarn and Webpack for front-end projects read how to migrate!

\- [The Bower Folks!](https://bower.io)

Built to re-use the rich existing ecosystem of developers and libraries.

Developed by engineers at Facebook, Exponent, Google, and Tilde.

Yarn engineers claim that it is fast, reliable, and a secure dependency manager.

However, not so fast, npm 5 is here **(tires screeching)**.

The re-work on how npm gets the exact same node modules everytime puts it slightly ahead ([not my words](https://github.com/siddharthkp/npm-cache-benchmark)).

> Determinism in the context of JavaScript package management is defined as always getting the exact same node_modules folder given a package.json and companion lock file.

[Read more on determinism - Yarn vs npm 5](HTTPs://yarnpkg.com/blog/2017/05/31/determinism/).

### Node modules directory

All dependencies installed by `npm` are stored in the `node_modules` directory. Build tools like webpack refer to this directory for dependencies, compiles them together with sources assets and bundles them as instructed in the `webpack.mix.js` file.

Upon bundling completion, it is safe to remove the `node_modules` directory, compress the project and deploy.

```bash
#install dependencies specified in package.json
$ yarn install

#this should work for most cases.
$ yarn production

#it is now safe to...
$ rm -rf node_modules/

#Go bezerk!
tar -zcvf /tmp/source.tar.gz .
```

The size of the `node_modules` directory is almost always frantically huge. With this simple optimization, off you go Santa's naughty list.

<br>

<div id="#composer-packages"></div>

## Composer Packages

> **tl;dr** No need to deploy the entire `vendor` directory.

The vendor directory stores dependencies specified in your `composer.json`.

The dependencies include stuff you would use in production, development, testing e.t.c. We wouldn't want development or testing suff to clout our production environment, or would we?

If your answer is, *NO we wouldn't*, read on.

```bash
#install dependencies specified in composer.json
$ composer install

#estimate file and folder space usage
$ du vendor/
100M   vendor/

#ignore dependencies specified as require-dev
$ composer install --no-dev

#new size estimation
$ du vendor/
30M    vendor/

#deploy a production optimized vendor directory
$ tar -zcvf /tmp/source.tar.gz .
```

Safe and easy on the bandwidth. My boss would love this.

<br>

<div id="#database-dumps"></div>

## Database Dumps

Dump the latest state of the database. Inspired by [lally elias](https://github.com/lykmapipo).

I think it is useful to have the latest database snapshot i.e. the schema and real seed-data, altogether, ready for deployment.

So, usually, we would do it like...

```bash
$ php artisan migrate:fresh --seed

$ mysqldump -u root -p laravel > storage/dumps/$(date -u +"%FT%T").sql
```
Now, imagine dragons...

```bash
$ php artisan db:dump mysql

Created Database Dump: yyyy-mm-dd-hh-mm-ss.sql
```

For a more eloquent api, reputable documentation and a well-maintained code, please check out:

- [larkinwhitaker/laravel-db-backup](https://github.com/larkinwhitaker/laravel-db-backup)
- [spatie/laravel-backup](https://docs.spatie.be/laravel-backup/v5/introduction)

<br>

<div id="#optimization"></div>

## Optimization

### Optimizing Autoloader

Optimize Composer's autoloader by running the command below:

```bash
composer install -o | --optimize-autoloader
```
The command above regenerates a list of all classes that need to be included in the project.

> **Note:**

> Prior to Laravel 5.5, we could also achieve this by running: `php artisan dump:autoload`

#### The Autoloading Story

Not so long ago, only developers writing idiomatic OO code used one source file per class definition. Not a piece of cake. Referencing other class definitions meant, one had to include so many includes at the top of the file. Terrible.

PHP autoloading came to the rescue, right about PHP 5's release. PHP developers could now magically make classes talk to each other. One less thing to worry about.

A code example:

```php
<?php

spl_autoload_register(function ($class_name) {

    require_once $DOCUMENT_ROOT.“classes/class.”.$class_name.“.php”;

});

$foo = new Foo;
$foo->hack();
$foo->hack();
$foo->hack();
$foo->shipIt();
$foo->fixInProduction();

//...
```
Wow! It couldn't get any better than this. "I beg to differ", said the Composer.

Composer introduced a much more straightforward API making it a gazillion times easier to autoload source files and vendor files.

```json
//composer.json
{
    "require": {
        "guzzlehttp/guzzle": "4.*",
        "monolog/monolog": "1.*"
    },
    "autoload": {
        "psr-4": {
            "Project\\": "src/Project/"
        }
    }
}
```

I swear, it can not get any better than this. ;)

### Optimizing Configuration Loading

Cut the framework some slack and optimize your configuration files by running the command below.

```bash
php artisan config:cache
```

Like we've previously covered, all of you application's configuration live in the `config` directory. The framework is responsible for making all those values available to application services whenever needed. Services like, connecting to the database, or, connecting to Google OAuth.

This step simply combines all of the configuration values into a single cached file making it super-duper easy for the framework to retrieve those values, hence a boost on your application's general performance.

### Optimizing Route Loading

Laravel is designed with a lot of special care to help developers look like they are being productive. It excels at being able to help them build very huge applications with less stress.

When the features of the applications we build become bigger, so do the route files.

Optimize the route files by running the command below:

```bash
php artisan route:cache
```

Routes need to be registered before they are used by the application. This command greatly speeds up the route registration process.

Optimization FTW!

### A good thing no closures is. Yes, hrrmmm.

Caching fails if I throw closures in my route files. So, I do not. Plus, there's nothing there for me to digest at run-time.

French [KISS](https://en.wikipedia.org/wiki/KISS_principle) your route and configuration files.

No closures is sometimes a good thing.

<br>

<div id="#shared-hosting"></div>

## Shared hosting

The usual directory structure in a shared hosting server looks sort of the structure below:

```bash
$ tree -L 1
.
├── public_ftp/
├── public_html/ -> /www/
├── tmp/
├── var/
├── www/

5 directories

```

The usual practice, i.e. deploying a static website is to dump everything in the `www/` directory. The easiest and straightforward way of deploying laravel apps takes a slightly different approach.

One creates a project directory at the same level with `www/`; so something like `awesome/`.

One dumps all of the project's source, maybe via FTP or git, if SSH access is available.

Gets a little trick from here on.

One needs move all of the contents of `/awesome/public/` directory to `/www/` so that the project can be reached from the public domain.

An innocent public directory looks like the tree structure below:

```bash
$ tree -aL 1
.
├── css/
├── favicon.ico
├── fonts/
├── .htaccess
├── img/
├── index.php
├── js/
├── mix-manifest.json
├── robots.txt
└── storage/ -> /home/joshua/projects/sdgphotos/storage/app/public

5 directories, 5 files

```

So, dump all that into your server's `www/`.

By now, you should be getting an error when you hit your public domain. If this the case, make sure your dotenv files are in order, and that they reflect the setup on your production environment.

Moving on, open the file `/awesome/public/index.php`. We will need to modify the path to where the framework registers the autoloader and boots up a Laravel application.

We see the lines

```php

//registers the autoloader
require __DIR__.'/../vendor/autoload.php';

//illuminates PHP development
$app = require_once __DIR__.'/../bootstrap/app.php';

```
We change them to

```php
//registers the autoloader
require __DIR__.'/../awesome/vendor/autoload.php';

//illuminates PHP development
$app = require_once __DIR__.'/../awesome/bootstrap/app.php';
```

If everything else was properly set, it'd be ok to hit the project from the public domain now.

### Gotchas

#### Optimizing

It is cumbersome to run optimizations on a shared hosting server, especially if you don't have SSH access.

One thing we could do to get around this, create an optimization handler for when we hit `/staging` from the address bar. Something like...

```php
<?php
//...

class StagingController extends Controller
{
	public function __construct()
	{
		//checks whether staging environment
		$this->middleware('staging');
	}

	public function index()
	{
		//create storage link
		Artisan::call('storage:link');

		//clear stuff...
		Artisan::call('view:clear');
		Artisan::call('cache:clear');
		Artisan::call('route:clear');
		Artisan::call('config:clear');
		Artisan::call('clear-compiled');
		Artisan::call('medialibrary:clear');

		//cache stuff...
		Artisan::call('route:cache');
		Artisan::call('config:cache');

		return redirect()->index(); //or something else.
	}
}
```

Now, we hit the route `http://yourdomain/staging` and... big-badda-boom!

See [gistfile](https://gist.github.com/joshuamabina/544e48c747a8ebba1b0142e5290a7728)

<div id="#last-words"></div>

## Last words

### Contributing

Found a typo? I accept pull requests.

Think I'm wrong, or you know a better way to do something? Please open an issue, I'd really love to learn more.

### Who should I yell at?

Do I disgust you? Did you enjoy this piece? Please share your slime or mime with me [@joshuamabina](https://twitter.com/joshuamabina)

Cheers!
