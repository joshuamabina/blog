# Laravel Deployment - Brain Dump!

Date: Thu Oct 19 14:08:18 2017 +0300

The following are some lessons I documented on deploying Laravel applications, mostly based on a shared-hosting context.

**Heads up!** All opinions are mine. Find yours!

<br>

## Contents

- [Server Requirements](#server-requirements)
- [About Dotenv](#about-dotenv)
- [Static Assets: css, sass, js and images](#static-assets)
- [Node Modules](#node-modules)
- [Composer Packages](#composer-packages)
- [Database Dumps](#database-dumps)
- [Caching for performance](#caching-for-performance)
- [Shared hosting](#shared-hosting)
- [TODO Docker](#docker)
- [TODO Envoyer/Forge](#envoyer)
- [Last words](#last-words)

<br>

<div id="#server-requirements"></div>

## Server Requirements

The Laravel framework has a few system requirements. Make sure you server meets the following:

- PHP >= 7.0.0
- OpenSSL PHP Extension
- PDO PHP Extension
- Mbstring PHP Extension
- Tokenizer PHP Extension
- XML PHP Extension

I wrote a script to test these server requirements.

See [gistfile](https://gist.github.com/joshuamabina/9575e46ba9e70a416ba80d6870fa846f).

<br>

<div id="#about-dotenv"></div>

## About Dotenv

### What is it?

Dotenv files are your friend. I like to think of them as **.ini files** on steriods. PHP uses ini files for configurations. Basically, simple text files composed of sections with key-value properties that define how a system is setup.

Here's a section copied from my php.ini file:

```ini
#/path/to/php/lib/php.ini

;;;;;;;;;;;;;;;;
; File Uploads ;
;;;;;;;;;;;;;;;;

; Whether to allow HTTP file uploads.
; http://php.net/file-uploads
file_uploads = On
```
### Why should you I use them?

Including your secret credentials in your source files, is not such a smart thing to do. They should be stored some place else. In your head, for instance.

*PHPDotenv (requires a link to resource)* was designed to allow the use of different configuration values in different environments.

A simple example of a `.env` file:

```bash
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64_application_key

DB_DATABASE=forge
DB_USERNAME=forge
DB_PASSWORD=secret
```

Use `.env` or `.env.production` or `.env.testing` (notice the convention) to store configuration values specific to the respective dot-environment.

### Why the convention?

Lets look at some code:

```bash
#modify the .env APP_KEY value
$ php artisan key:generate

#modify the .env.testing APP_KEY value
$ php artisan key:generate --env=testing
```

Convetions are good. They just work!

### Caveat: Don't source your credentials

DO NOT EVER change `config/something.php` to store credentials.

```php
#good
'mysql' => [
    'driver' => 'mysql',
    'host' => env('DB_HOST', '127.0.0.1'),
    'port' => env('DB_PORT', '3306'),
    'database' => env('DB_DATABASE', 'fake_db'),
    'username' => env('DB_USERNAME', 'fake_user'),
    'password' => env('DB_PASSWORD', 'fake_secret'),
    //...
],
```

I would gladly give anyone a rope for which they hang themselves before letting them dump credentials in a `config/database.php` for whatsoever sane reason they think they have.

### Caveat: Don't version your .env files

The `.env[.production|.testing|.environment]` file is (and must) not be versioned.

It is a common practice to stub all required environment variables in a `.env.example` file and version that file. So for testing, I would have (recall the convention) `.env.testing.example`.

<br>

<div id="#static-assets"></div>

## Static Assets: css, sass, js and images.

> **tl;dr** DO NOT USE `public/assets` to store your source static assets.

Your `project/resources/assets` directory is your static assets' spouse. Do not set them apart. In other words, store all your source static assets in `project/resources/assets` instead of `public/assets`. The `public/assets` directory is (should be) generated by your build tool (i.e. laravel-mix).

Here is a link to a nice article [Introducing Laravel Mix](https://mattstauffer.com/blog/introducing-laravel-mix-new-in-laravel-5-4/).

In a nutshell:

- Use package-manager to install dependencies:

    ```bash
    $ yarn install
    ```
- Setup Laravel Mix:

    ```js
    //file: project/webpack.mix.js

    const { mix } = require('laravel-mix');

    mix.sass('resources/assets/sass/app.scss', 'public/css')
       .js('resources/assets/js/app.js', 'public/js')
       .copy('resources/assets/img', 'public/img');
    ```
- Bootstrap your vendor assets:

    ```js
    //file: project/resources/assets/js/bootstrap.js

    window.$ = window.jQuery = require('jquery');
    require('bootstrap-sass');
    ```

- Bundle your source and vendor assets together:

    ```js
    //file: project/resources/assets/js/app.js
    require('./bootstrap');

    /** custom libraries **/
    require('./lib/ajax');
    require('./lib/custom-cool-tool');

- Compile all static assets for specified environment

    ```bash
    #for development
    $ yarn dev

    #for production
    $ yarn production
    ```

Is it not easy and nice to just think about deploying already optimized stylesheets, javascripts and images?

<br>

<div id="#node-modules"></div>

## Node Modules

> **tl;dr** There is no need to deploy the project with the `node_modules` directory.

### A short walk down memory lane

Node drastically changed how JavaScript development took form.

While it is true that the concept of sanely managing 3rd-party code has been around for quite a long-time (git-submodules, for instance), this was not much of the case in the JavaScript ecosystem.

Node and affiliates ploughed the JavaScript planet for the better. Then [bower](https://bower.io), [ender](http://www.enderjs.com/), [volo](http://volojs.org/) and everything else, quickly errupted from JavaScript's volcanic core, shaking the Internet's crust, hard.

### What is npm?

Their [website](https://npmjs.com), so eloquently states, **&ldquo;npm does not stand for node package manager&rdquo;**.

*Unrelated, **GNU** stands for **GNU's Not UNIX.***

Why npm does not stand for node package manager?

> To be more accurate, npm isn’t “the package manager for Node.js”, but “a package manager for JavaScript”.

\- [For more, read this long thread.](https://github.com/BloombergMedia/whatiscode/pull/34)

### The Story of Yarn - Yet another package manager.

An npm alternative and a bower replacement.

> ...psst! While Bower is maintained, we recommend using Yarn and Webpack for front-end projects read how to migrate!

\- [The Bower Folks!](https://bower.io)

Built to re-use the rich existing ecosystem of developers and libraries.

Developed by engineers at Facebook, Exponent, Google, and Tilde.

Yarn engineers claim that it is fast, reliable, and a secure dependency manager.

However, not so fast, npm 5 is here **(tires screeching)**.

The re-work on how npm gets the exact same node modules everytime puts it slightly ahead ([not my words](https://github.com/siddharthkp/npm-cache-benchmark)).

> Determinism in the context of JavaScript package management is defined as always getting the exact same node_modules folder given a package.json and companion lock file.

[Read more on determinism - Yarn vs npm 5](HTTPs://yarnpkg.com/blog/2017/05/31/determinism/).

### Node modules directory

All dependencies installed by `npm` are stored in the `node_modules` directory. Build tools like webpack refer to this directory for dependencies, compiles them together with sources assets and bundles them as instructed in the `webpack.mix.js` file.

Upon bundling completion, it is safe to remove the `node_modules` directory, compress the project and deploy.

```bash
#install dependencies specified in package.json
$ yarn install

#this should work for most cases.
$ yarn production

#it is now safe to...
$ rm -rf node_modules/

#Go bezerk!
tar -zcvf /tmp/source.tar.gz .
```

The size of the `node_modules` directory is almost always frantically huge. With this simple optimization, off you go Santa's naughty list.

<br>

<div id="#composer-packages"></div>

## Composer Packages

> **tl;dr** No need to deploy the entire `vendor` directory.

The vendor directory stores dependencies specified in your `composer.json`.

The dependencies include stuff you would use in production, development, testing e.t.c. We wouldn't want development or testing suff to clout our production environment, or would we?

If your answer is, *NO we wouldn't*, read on.

```bash
#install dependencies specified in composer.json
$ composer install

#estimate file and folder space usage
$ du vendor/
100M   vendor/

#ignore dependencies specified as require-dev
$ composer install --no-dev

#new size estimation
$ du vendor/
30M    vendor/

#deploy a production optimized vendor directory
$ tar -zcvf /tmp/source.tar.gz .
```

Safe and easy on the bandwidth. My boss would love this.

<br>

<div id="#database-dumps"></div>

## Database Dumps

Dump the latest state of the database. Inspired by [lally elias](https://github.com/lykmapipo).

I think it is useful to have the latest database snapshot i.e. the schema and real seed-data, altogether, ready for deployment.

So, usually, we would do it like...

```bash
$ php artisan migrate:fresh --seed

$ mysqldump -u root -p laravel > storage/dumps/$(date -u +"%FT%T").sql
```
Now, imagine dragons...

```bash
$ php artisan database:dump mysql

Created Database Dump: yyyy-mm-dd-hh-mm-ss.sql
```

For a more eloquent api, reputable documentation and a well-maintained code, please check out:

- [larkinwhitaker/laravel-db-backup](https://github.com/larkinwhitaker/laravel-db-backup)
- [spatie/laravel-backup](https://docs.spatie.be/laravel-backup/v5/introduction)

<br>

<div id="#caching-for-performance"></div>

## Caching for performance

- [ ] Assets
- [ ] Configurations
- [ ] Routes

<br>

<div id="#shared-hosting"></div>

### Shared hosting

- [ ] Common and straightforward
- [ ] Symlinking `public_html` to `public`
- [ ] Extending the \Illuminate\Foundation\Application class

<br>

<div id="#last-words"></div>

## Last words

### A good thing no closures is. Yes, hrrmmm.

Caching fails if I throw closures in my route files. So, I do not. Plus, there's nothing there for me to digest at run-time.

French [KISS](https://en.wikipedia.org/wiki/KISS_principle) your route and configuration files.

No closures is sometimes a good thing.

### TODO Shared hosting vs VPS

> **tl;dr** Shared hosting, culprit of Laravel hosting.

### Who you should yell at

Do not forget to dump all your slimy disgust to mabinajoshua@gmail.com. He sometimes empties his trash.

Found a typo? I accept pull requests.

Cheers!
